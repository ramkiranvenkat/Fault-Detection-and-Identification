# -*- coding: utf-8 -*-
"""FDI_SOM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1riXR2bTDWWVIytrVcgaSi9wYSbN43LuN
"""

!pip install sklearn-som
import tensorflow as tf
import numpy as np
import numpy.linalg as la
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import urllib
import sys
import os
import zipfile
import torch.nn as nn
import torch.nn.functional as F
import torch
import torch.optim as optim
from torch.autograd import Variable
from torch.utils.data import Dataset, DataLoader, random_split
import numpy.random as r

import torchvision
from torchvision.datasets import FashionMNIST
from torchvision import transforms
import pandas as pd
from google.colab import drive
from scipy.stats import skew
from scipy.stats import kurtosis
from sklearn import svm
from sklearn.gaussian_process.kernels import DotProduct, WhiteKernel, RBF
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, VotingClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from sklearn.svm import LinearSVC
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.svm import OneClassSVM
from sklearn.metrics import confusion_matrix
from sklearn.ensemble import IsolationForest
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import roc_auc_score
from sklearn.neighbors import LocalOutlierFactor
from sklearn_som.som import SOM

drive.mount('/content/drive')

Xt = np.load('/content/drive/My Drive/TSF_1.npy') # load
y = np.load('/content/drive/My Drive/TSC_1.npy')

Xmax = np.amax(Xt,0)
Xmin = np.amin(Xt,0)
X = np.zeros_like(Xt)

#Normalization
difvals = Xmax-Xmin
for i in range(Xt.shape[0]):
  X[i,:] = np.divide(Xt[i,:] - Xmin, difvals)
Xmax = np.amax(X,0)
Xmin = np.amin(X,0)
print(Xmax,Xmin)

Xpass = []
Xfail = []
y_true = []
d = 10
pca_us = PCA(n_components = d)
Xpca = pca_us.fit_transform(X)

for i in range(X.shape[0]):
  if y[i] == 0:
    Xpass.append(Xpca[i])
    y_true.append(1)
  else:
    Xfail.append(Xpca[i])
    y_true.append(-1)

Xpass = np.array(Xpass)
Xfail = np.array(Xfail)
y_true = np.array(y_true)
print(Xpass.shape,Xfail.shape)

N = int(0.8*Xpass.shape[0])
Xus_train = Xpass[:N]
Nf = Xfail.shape[0]
Xus_test  = np.vstack((Xfail,Xpass[N:]))
print(Xus_train.shape,Xus_test.shape,y_true.shape)
print(y_true)

clf = SOM(m=30,n=30,dim=d)
dist = clf.fit_transform(Xus_train)

dist_test = np.amin(clf.transform(Xus_test),axis=1)

print(dist_test.shape)

def plot_hist(b,h,b1,h1,figno,name):
  b = (b[1:]+b[:-1])/2
  b1 = (b1[1:]+b1[:-1])/2
  print(b.shape,h.shape)
  plt.figure(figno)
  plt.plot(b,h,lw=2,label='Fail')
  plt.plot(b1,h1,lw=2,label='Pass')
  plt.legend()
  plt.title(name)
  plt.grid()
  plt.show()

def get_row(y,l):
  i1 = 0
  i2 = 0
  for i in range(y.shape[0]):
    if (y[i] < l):
      i1 += 1
    else:
      i2 += 1
  return i1, i2

def roc_data(p,n):
  max_level = max(max(p),max(n))
  min_level = min(min(p),min(n))
  tpr = [0]
  fpr = [0]
  eps = 1e-6
  for i in range(1000):
    level = min_level + i*(max_level-min_level)/1000.0
    tp,fn = get_row(p,level)
    fp,tn = get_row(n,level)
    tpr.append(tp/(tp+fn + eps))
    fpr.append(fp/(fp+tn + eps))
  return tpr, fpr

tpr, fpr = roc_data(dist_test[Nf:],dist_test[:Nf])
fpr.append(1)
tpr.append(1)
lw = 2
plt.xlim([0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate', fontsize=14)
plt.ylabel('True Positive Rate', fontsize=14)
plt.title('Receiver operating characteristic', fontsize=16)

plt.plot(fpr, tpr, label='SOM')
plt.plot([0, 1], [0, 1], color='navy', label='No Learning', lw=lw, linestyle='--')
plt.legend(loc="lower right", fontsize=12)