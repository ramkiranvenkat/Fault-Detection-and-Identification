# -*- coding: utf-8 -*-
"""FDI_us

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FCZTtCvyFuqCk3erPvJWHLum0tCmlptw
"""

!pip install sklearn-som
import tensorflow as tf
import numpy as np
import numpy.linalg as la
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import urllib
import sys
import os
import zipfile
import torch.nn as nn
import torch.nn.functional as F
import torch
import torch.optim as optim
from torch.autograd import Variable
from torch.utils.data import Dataset, DataLoader, random_split

import torchvision
from torchvision.datasets import FashionMNIST
from torchvision import transforms
import pandas as pd
from google.colab import drive
from scipy.stats import skew
from scipy.stats import kurtosis
from sklearn import svm
from sklearn.gaussian_process.kernels import DotProduct, WhiteKernel, RBF
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, VotingClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from sklearn.svm import LinearSVC
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.svm import OneClassSVM
from sklearn.metrics import confusion_matrix
from sklearn.ensemble import IsolationForest
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import roc_auc_score
from sklearn.neighbors import LocalOutlierFactor
from sklearn_som.som import SOM

drive.mount('/content/drive')

ROCnames = []
fprArray = []
tprArray = []

Xt = np.load('/content/drive/My Drive/TSF_1.npy') # load
y = np.load('/content/drive/My Drive/TSC_1.npy')

ids = np.load('/content/drive/My Drive/Kmeans_data/TSI_4.npy')
Xt_n = np.load('/content/drive/My Drive/Kmeans_data/TSF_4.npy') # load
y_n = np.load('/content/drive/My Drive/Kmeans_data/TSC_4.npy')
print(Xt.shape)

Xmax = np.amax(Xt,0)
Xmin = np.amin(Xt,0)
X = np.zeros_like(Xt)

#Normalization
difvals = Xmax-Xmin
for i in range(Xt.shape[0]):
  X[i,:] = np.divide(Xt[i,:] - Xmin, difvals)
Xmax = np.amax(X,0)
Xmin = np.amin(X,0)
print(Xmax,Xmin)

Xmax = np.amax(Xt_n,0)
Xmin = np.amin(Xt_n,0)
Xn = np.zeros_like(Xt_n)

#Normalization
difvals = Xmax-Xmin
for i in range(Xt.shape[0]):
  Xn[i,:] = np.divide(Xt_n[i,:] - Xmin, difvals)
Xmax = np.amax(Xn,0)
Xmin = np.amin(Xn,0)
print(Xmax,Xmin)

y_true = []
for i in range(X.shape[0]):
  if y[i] == 0:
    y_true.append(1)
  else:
    y_true.append(-1)
y_true = np.array(y_true)

pca_us = PCA(n_components = 60)
Xpca = pca_us.fit_transform(X)

y_pred = []
y_score = []
OCSVM = OneClassSVM(gamma='auto',kernel='rbf')
y_pred.append(OCSVM.fit_predict(Xpca))
y_score.append(OCSVM.score_samples(Xpca))

iso_for = IsolationForest(n_estimators=100)
y_pred.append(iso_for.fit_predict(Xpca))
y_score.append(iso_for.score_samples(Xpca))

plt.figure(1,figsize=(8, 8))#,dpi=300)

from sklearn.metrics import accuracy_score

# Compute ROC curve and ROC area for each class
classfier_names = ['OV-SVM','Iso Forest']
ROCnames += classfier_names
itr = 0
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in [0,1]:
  print(accuracy_score(y_true, y_pred[i]))
  fpr[i], tpr[i], _ = roc_curve(y_true, y_score[i])
  roc_auc[i] = auc(fpr[i], tpr[i])

  fprArray.append(fpr[i])
  tprArray.append(tpr[i])
  # Compute micro-average ROC curve and ROC area
  fpr["micro"], tpr["micro"], _ = roc_curve(y_true.ravel(), y_score[i].ravel())
  roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])

  plt.figure(1,figsize=(8, 6))#,dpi=300)
  lw = 2
  colorV = np.random.rand(1,3)
  plt.plot(fpr[i], tpr[i],color = (colorV[0][0],colorV[0][1],colorV[0][2]),
          lw=lw, label='ROC curve'+' ' + classfier_names[itr] +' (Acc = %0.2f)' % roc_auc[i])
  plt.legend(loc="lower right")
  if (itr == 0):
    plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
    plt.xlabel('False Positive Rate',fontsize = 12)
    plt.ylabel('True Positive Rate',fontsize = 12)
    plt.title('Receiver operating characteristic example', fontsize = 15)
    plt.yticks(fontsize=12)
    plt.yticks(fontsize=12)
    plt.grid()
  plt.xlim([0.0, 1.0])
  plt.ylim([0.0, 1.05])
  itr += 1

ROCnames.clear()
fprArray.clear()
tprArray.clear()

print(ROCnames,fprArray,tprArray)

Xpass = []
Xfail = []
y_true = []

pca_us = PCA(n_components = 60)
Xpca = pca_us.fit_transform(X)

for i in range(X.shape[0]):
  if y[i] == 0:
    Xpass.append(Xpca[i])
    y_true.append(1)
  else:
    Xfail.append(Xpca[i])
    y_true.append(-1)

Xpass = np.array(Xpass)
Xfail = np.array(Xfail)
y_true = np.array(y_true)
print(Xpass.shape,Xfail.shape)

N = int(0.8*Xpass.shape[0])
Xus_train = Xpass[:N]
Nf = Xfail.shape[0]
Xus_test  = np.vstack((Xfail,Xpass[N:]))
print(Xus_train.shape,Xus_test.shape,y_true.shape)
print(y_true)

def sepPlot(distance,n,avg_dir,mean_dist):
  dm = []
  dv = []
  dw = []
  mean_val = np.sort(mean_dist)
  for i in range(distance.shape[0]):
    dm.append(np.min(distance[i]))
    v = np.sort(distance[i])/la.norm(distance[i])
    similarity  = np.dot(v,avg_dir)
    dv.append(similarity)
    dw.append(np.arccos(similarity)*np.min(distance[i])/la.norm(mean_val))
  dm = np.array(dm)
  dv = np.array(dv)
  dw = np.array(dw)
  '''
  plt.plot(np.log10(dm))
  plt.show()
  plt.title(str(n) + '-clusters')

  plt.plot(dv)
  plt.show()
  plt.title(str(n) + '-clusters')
  '''
  return dv, dm, dw
  
def direction(d):
  v = np.sort(d[0])/la.norm(d[0])
  for i in range(1,d.shape[0],1):
    v = i*v/(i+1) + 1/(i+1)*np.sort(d[i])/la.norm(d[i])
  return v

def plot_hist(b,h,b1,h1,figno,name):
  b = (b[1:]+b[:-1])/2
  b1 = (b1[1:]+b1[:-1])/2
  print(b.shape,h.shape)
  plt.figure(figno)
  plt.plot(b,h,lw=2,label='Fail')
  plt.plot(b1,h1,lw=2,label='Pass')
  plt.legend()
  plt.title(name)
  plt.grid()
  plt.show()

def get_row(y,l):
  i1 = 0
  i2 = 0
  for i in range(y.shape[0]):
    if (y[i] < l):
      i1 += 1
    else:
      i2 += 1
  return i1, i2

def roc_data(p,n):
  max_level = max(max(p),max(n))
  min_level = min(min(p),min(n))
  tpr = [0]
  fpr = [0]
  eps = 1e-6
  acc = 0
  for i in range(1000):
    level = min_level + i*(max_level-min_level)/1000.0
    tp,fn = get_row(p,level)
    fp,tn = get_row(n,level)
    if (tp+tn)/(tp+tn+fn+fp) > acc:
      acc = (tp+tn)/(tp+tn+fn+fp)
    tpr.append(tp/(tp+fn + eps))
    fpr.append(fp/(fp+tn + eps))
  print('Accuracy: ',acc)
  return tpr, fpr

itr = 0
for ncluster in range(300,301,300):
  kmeans = KMeans(n_clusters=ncluster, random_state=0)
  kmeans.fit(Xus_train)
  avg_distance_dir = direction(kmeans.transform(Xus_train))
  distance = kmeans.transform(Xus_test)
  distance_train = kmeans.transform(Xus_train)
  mean_dist = np.mean(distance_train,axis=0)

  classes = {}
  for i in range(Xus_train.shape[0]):
    idx = np.argmin(distance_train[i])
    if idx in classes.keys():
      classes[idx] += [i]
    else:
      classes[idx] = []
      classes[idx] += [idx]

  mu = []
  sig = []
  for i in range(ncluster):
    dc = Xus_train[classes[i]]
    mu.append(np.mean(dc,axis=0))
    sig.append(np.cov(dc.T))
 
  mu = np.array(mu)
  sig = np.array(sig)

  dist_gmm = []
  y_pred_new = []
  for i in range(Xus_test.shape[0]):
    idx = np.argmin(distance[i])

    dp = Xus_test[i]
    dist_gmm.append((dp-mu[idx]) @ la.inv(sig[idx]) @ (dp-mu[idx]).T)
    if (dp-mu[idx]) @ la.inv(sig[idx]) @ (dp-mu[idx]).T < 3:
      y_pred_new.append(1)
    else:
      y_pred_new.append(-1)
  
  y_true_new = []
  for i in range(Xus_test.shape[0]):
    if i < Nf:
      y_true_new.append(-1)
    else:
      y_true_new.append(1)

  y_pred_new = np.array(y_pred_new)
  y_true_new = np.array(y_true_new)


  print(accuracy_score(y_true_new, y_pred_new))
  dist_gmm = np.array(dist_gmm)
  #prediction = kmeans.predict(Xus_test)
  sm, md, nf = sepPlot(distance,ncluster,avg_distance_dir,mean_dist)
  fsm = np.arccos(sm[:Nf])
  psm = np.arccos(sm[Nf:])
  fmd = md[:Nf]
  pmd = md[Nf:]
  fnf = nf[:Nf]
  pnf = nf[Nf:]

  fgf = dist_gmm[:Nf]
  pgf = dist_gmm[Nf:]

  fsm_hist,fsm_bins = np.histogram(fsm,bins = 100)
  psm_hist,psm_bins = np.histogram(psm,bins = 100)
  fmd_hist,fmd_bins = np.histogram(fmd,bins = 100)
  pmd_hist,pmd_bins = np.histogram(pmd,bins = 100)
  fnf_hist,fnf_bins = np.histogram(fnf,bins = 100)
  pnf_hist,pnf_bins = np.histogram(pnf,bins = 100)
  fgf_hist,fgf_bins = np.histogram(fgf,bins = 100)
  pgf_hist,pgf_bins = np.histogram(pgf,bins = 100)

  plot_hist(fsm_bins,fsm_hist,psm_bins,psm_hist,itr,'Similarity')
  plot_hist(fmd_bins,fmd_hist,pmd_bins,pmd_hist,itr+1,'Min Dist')
  plot_hist(fnf_bins,fnf_hist,pnf_bins,pnf_hist,itr+1,'New Features')
  plot_hist(fgf_bins,fgf_hist,pgf_bins,pgf_hist,itr+1,'GMM Features')

  lw = 2
  plt.xlim([0, 1.0])
  plt.ylim([0.0, 1.05])
  plt.xlabel('False Positive Rate', fontsize=14)
  plt.ylabel('True Positive Rate', fontsize=14)
  plt.title('Receiver operating characteristic', fontsize=16)

  tpr, fpr = roc_data(psm,fsm)
  tpr_md, fpr_md = roc_data(pmd,fmd)
  tpr_nf, fpr_nf = roc_data(pnf,fnf)
  tpr_gf, fpr_gf = roc_data(pgf,fgf)
  fpr.append(1)
  tpr.append(1)
  fpr_md.append(1)
  tpr_md.append(1)
  fpr_nf.append(1)
  tpr_nf.append(1)
  fpr_gf.append(1)
  tpr_gf.append(1)
  plt.figure(1)

  plt.plot(fpr, tpr, label='K-means Similarity')
  plt.plot(fpr_md, tpr_md, label='K-means Min Distance')
  plt.plot(fpr_gf, tpr_gf, label='K-means Min GMM')

  ROCnames.append('K-means Similarity')
  ROCnames.append('K-means Min Distance')
  ROCnames.append('K-means Gaussian')
  fprArray.append(fpr)
  tprArray.append(tpr)
  fprArray.append(fpr_md)
  tprArray.append(tpr_md)
  fprArray.append(fpr_gf)
  tprArray.append(tpr_gf)
  plt.plot(fpr_nf, tpr_nf, label='K-means New Features')
  plt.plot([0, 1], [0, 1], color='navy', label='No Learning', lw=lw, linestyle='--')
  plt.legend(loc="lower right", fontsize=12)
  itr += 2

print(ROCnames,fprArray,tprArray)

Xpass_t = []
Xfail_t = []

Xpca_t = pca_us.transform(Xn)
id_p = []
id_f = []
for i in range(Xn.shape[0]):
  if y_n[i] == 0:
    Xpass_t.append(Xpca_t[i])
    id_p.append(ids[i])
  else:
    Xfail_t.append(Xpca_t[i])
    id_p.append(ids[i])
Xpass_t = np.array(Xpass_t)
Xfail_t = np.array(Xfail_t)

distance = kmeans.transform(Xpass_t)
psm, mdp, pnf = sepPlot(distance,ncluster,avg_distance_dir)
distance = kmeans.transform(Xfail_t)
fsm, mdf, fnf = sepPlot(distance,ncluster,avg_distance_dir)

fsm = np.arccos(fsm)
psm = np.arccos(psm)

fsm_hist,fsm_bins = np.histogram(fsm,bins = 100)
psm_hist,psm_bins = np.histogram(psm,bins = 100)
fnf_hist,fnf_bins = np.histogram(fnf,bins = 100)
pnf_hist,pnf_bins = np.histogram(pnf,bins = 100)

plot_hist(fsm_bins,fsm_hist,psm_bins,psm_hist,itr,'Similarity')

lw = 2
plt.xlim([0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate', fontsize=14)
plt.ylabel('True Positive Rate', fontsize=14)
plt.title('Receiver operating characteristic', fontsize=16)

tpr, fpr = roc_data(psm,fsm)
tpr_md, fpr_md = roc_data(pmd,fmd)
  
fpr.append(1)
tpr.append(1)
fpr_md.append(1)
tpr_md.append(1)

plt.plot(fpr, tpr, label='K-means Similarity')
plt.plot(fpr_md, tpr_md, label='K-means Min Distance')
plt.plot([0, 1], [0, 1], color='navy', label='No Learning', lw=lw, linestyle='--')
plt.legend(loc="lower right", fontsize=12)
itr += 2

Xpass = []
Xfail = []
y_true = []
d = 10
pca_us = PCA(n_components = d)
Xpca = pca_us.fit_transform(X)

for i in range(X.shape[0]):
  if y[i] == 0:
    Xpass.append(Xpca[i])
    y_true.append(1)
  else:
    Xfail.append(Xpca[i])
    y_true.append(-1)

Xpass = np.array(Xpass)
Xfail = np.array(Xfail)
y_true = np.array(y_true)
print(Xpass.shape,Xfail.shape)

N = int(0.8*Xpass.shape[0])
Xus_train = Xpass[:N]
Nf = Xfail.shape[0]
Xus_test  = np.vstack((Xfail,Xpass[N:]))
print(Xus_train.shape,Xus_test.shape,y_true.shape)
print(y_true)

clf = SOM(m=30,n=30,dim=d)
dist = clf.fit_transform(Xus_train)

dist_test = np.amin(clf.transform(Xus_test),axis=1)

def plot_hist(b,h,b1,h1,figno,name):
  b = (b[1:]+b[:-1])/2
  b1 = (b1[1:]+b1[:-1])/2
  print(b.shape,h.shape)
  plt.figure(figno)
  plt.plot(b,h,lw=2,label='Fail')
  plt.plot(b1,h1,lw=2,label='Pass')
  plt.legend()
  plt.title(name)
  plt.grid()
  plt.show()

def get_row(y,l):
  i1 = 0
  i2 = 0
  for i in range(y.shape[0]):
    if (y[i] < l):
      i1 += 1
    else:
      i2 += 1
  return i1, i2

def roc_data(p,n):
  max_level = max(max(p),max(n))
  min_level = min(min(p),min(n))
  tpr = [0]
  fpr = [0]
  eps = 1e-6
  acc = 0
  for i in range(1000):
    level = min_level + i*(max_level-min_level)/1000.0
    tp,fn = get_row(p,level)
    fp,tn = get_row(n,level)
    if (tp+tn)/(tp+tn+fn+fp) > acc:
      acc = (tp+tn)/(tp+tn+fn+fp)
    tpr.append(tp/(tp+fn + eps))
    fpr.append(fp/(fp+tn + eps))
  print("Accuracy: ",acc)
  return tpr, fpr

tpr, fpr = roc_data(dist_test[Nf:],dist_test[:Nf])
fpr.append(1)
tpr.append(1)
plt.figure(1)
plt.plot(fpr, tpr, label='SOM')
plt.legend(loc="lower right", fontsize=12)

ROCnames.append('SOM')
fprArray.append(fpr)
tprArray.append(tpr)

for i in range(5):
  print(len(fprArray[i]),len(tprArray[i]))

import json
with open("usfdi_algos.txt", "w") as fp:
  json.dump(ROCnames, fp)

fprArray = np.array(fprArray)
tprArray = np.array(tprArray)

np.save('usfdi_fpr.npy', fprArray) # save
np.save('usfdi_tpr.npy', tprArray)

plt.savefig('unsupervised.jpg')